// Code generated by goctl. DO NOT EDIT.

package request_status

import (
	"context"
	"database/sql"
	"fmt"
	"nrs_customer_module_backend/internal/global"
	"nrs_customer_module_backend/internal/model/card"
	"strings"
	"time"
	"nrs_customer_module_backend/internal/types"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	requestStatusFieldNames          = builder.RawFieldNames(&RequestStatus{})
	requestStatusRows                = strings.Join(requestStatusFieldNames, ",")
	requestStatusRowsExpectAutoSet   = strings.Join(stringx.Remove(requestStatusFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	requestStatusRowsWithPlaceHolder = strings.Join(stringx.Remove(requestStatusFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
	firstDay, lastDay = global.GetFirstAndLastDayOfMonth()
)

type (
	requestStatusModel interface {
		Insert(ctx context.Context, data *RequestStatus) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*RequestStatus, error)
		Update(ctx context.Context, data *RequestStatus) error
		Delete(ctx context.Context, id int64) error
		FindAllPending(ctx context.Context) (int, error)
		FindAllMonthly(ctx context.Context,status int64) (int, error)
		FindAllTitle(ctx context.Context) (*[]Title, error)
		FindMemberRequestList(ctx context.Context, from string, req *types.GetListRegistrationReq) (*[]MemberRequestList, error)
	}

	defaultRequestStatusModel struct {
		conn  sqlx.SqlConn
		table string
	}

	RequestStatus struct {
		Id                  int64     `db:"id"`
		Guid                string    `db:"guid"`
		MembershipRequestId int64     `db:"membership_request_id"`
		PaymentStatus       int64     `db:"payment_status"` // 0: Free, 1; Pending, 2 Success, 3 Failed
		Status              int64     `db:"status"`         // 1:Pending, 2: Approve, 3: Reject
		StatusUpdated       time.Time `db:"status_updated"`
		StaffId             int64     `db:"staff_id"`
		OutletId            int64     `db:"outlet_id"`
		Updated             time.Time `db:"updated"`
		Created             time.Time `db:"created"`
		Active              int64     `db:"active"` // 0: Inactive, 1:Inactive
	}

	//title & description
	Title struct {
		Id                  int64     `db:"id"`
		Guid                string    `db:"guid"`
		Title 				string     `db:"title"`
		Description 		string     `db:"description"`
		Updated             time.Time `db:"updated"`
		Created             time.Time `db:"created"`
		Active              int64     `db:"active"` // 0: Inactive, 1:Inactive
	}

	Data struct {
		RegistrationSummary []Summary `json:"registration_summary"`
		MemberSummary       []Summary `json:"member_summary"`
		CardSummary         []card.CardInfo    `json:"card_summary"`
	}
	
	Summary struct {
		Title       string `json:"title"`
		Value       string `json:"value"`
		Description string `json:"description"`
		Percentage  string `json:"percentage,omitempty"`
	}

	MemberRequestList struct {
		Guid 			string    `db:"guid"`
		Status 			int64     `db:"status"`
		CusFullname 	string     `db:"fullname"`
		CusEmail 		string     `db:"email"`
		CusIcno			string     `db:"icno"`
		CusCardTitle 	string     `db:"title"`
		CusCardCode 	string     `db:"code"`
	}

	
	
)

func newRequestStatusModel(conn sqlx.SqlConn) *defaultRequestStatusModel {
	return &defaultRequestStatusModel{
		conn:  conn,
		table: "`request_status`",
	}
}

func (m *defaultRequestStatusModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultRequestStatusModel) FindOne(ctx context.Context, id int64) (*RequestStatus, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", requestStatusRows, m.table)
	var resp RequestStatus
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultRequestStatusModel) Insert(ctx context.Context, data *RequestStatus) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, requestStatusRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.Guid, data.MembershipRequestId, data.PaymentStatus, data.Status, data.StatusUpdated, data.StaffId, data.OutletId, data.Updated, data.Created, data.Active)
	return ret, err
}

func (m *defaultRequestStatusModel) Update(ctx context.Context, data *RequestStatus) error {
	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, requestStatusRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, data.Guid, data.MembershipRequestId, data.PaymentStatus, data.Status, data.StatusUpdated, data.StaffId, data.OutletId, data.Updated, data.Created, data.Active, data.Id)
	return err
}

func (m *defaultRequestStatusModel) tableName() string {
	return m.table
}

//count all from request_status table to get all the data which is having status = 1 [represent as pending] 
func (m *defaultRequestStatusModel) FindAllPending(ctx context.Context) (int, error) {
	countQuery := `
		SELECT COUNT(*) 
		FROM request_status r
		INNER JOIN membership_request m ON r.membership_request_id = m.id 
		AND m.category = 11 AND m.active = 1
		WHERE r.active = 1 AND r.status = 1 
	`

	var count int
	err := m.conn.QueryRowCtx(ctx, &count, countQuery)
	if err != nil {
		return 0, err
	}

	return count, nil
}

//count all the request that is approved [status = 2] or rejected [status = 3] in current month
func (m *defaultRequestStatusModel) FindAllMonthly(ctx context.Context,status int64) (int, error) {

	countQuery := `
	SELECT COUNT(*) 
	FROM request_status r
	INNER JOIN membership_request m ON r.membership_request_id = m.id 
	AND m.active = 1 
	AND m.category = 11
	WHERE r.active = 1 
	AND r.status = ? 
	AND r.status_updated >= ?
	AND r.status_updated <= ?
	`

	var count int
	err := m.conn.QueryRowCtx(ctx, &count, countQuery,status,firstDay,lastDay)
	if err != nil {
		return 0, err
	}

	return count, nil
}

// UI title table use to display the title and description in struct  
func (m *defaultRequestStatusModel) FindAllTitle(ctx context.Context) (*[]Title, error) {
    query := ("SELECT * FROM ui_title WHERE `active` = 1 AND `id` IN (7,8,9,10,11,12) ORDER BY id") //7，8，9 -> registration summary  10,11 -> member_summary  12-> card_summary
    var resp []Title
    err := m.conn.QueryRowsCtx(ctx, &resp, query)
    switch err {
    case nil:
        return &resp, nil
    case sqlx.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}


func (m *defaultRequestStatusModel) FindMemberRequestList(ctx context.Context, from string,req *types.GetListRegistrationReq) (*[]MemberRequestList, error) {
	filterCondition := ""
	searchCondition := ""
	
	status := req.Status
	filterDay := req.Code
	search := req.Search
	/*
	status:
	"1": true, // Pending
	"2": true, // Approve
	"3": true, // Reject
	"4": true, // All

	from: 
	11 - Register
	12 - Renew
	13 - Upgrade

	*/

	if !global.CheckIsEmpty(fmt.Sprint(filterDay))  && filterDay > 0 {
		filterCondition = fmt.Sprintf(` AND DATE(rs.created) >= DATE_SUB(CURDATE(), INTERVAL %d DAY) `, filterDay)
	}

	if !global.CheckIsEmpty(search) {
		searchCondition = fmt.Sprintf(`AND (mr.email LIKE '%%%s%%' OR mr.icno LIKE '%%%s%%' OR mr.contact LIKE '%%%s%%') `, search, search, search)

	}

 	var query string
 	var err error 
 	var resp []MemberRequestList

	switch status {
	case "1","2","3":
		query = fmt.Sprintf(`SELECT rs.guid, rs.status,mr.fullname, mr.email, mr.icno, c.title, c.code
		FROM request_status as rs
		INNER JOIN membership_request mr ON mr.id = rs.membership_request_id AND mr.active = 1 AND mr.category = ?
		%s
		INNER JOIN card c ON c.id = mr.card_id AND c.active = 1
		WHERE rs.active = 1 AND rs.status = ?
		%s`,searchCondition,filterCondition)

		err = m.conn.QueryRowsCtx(ctx, &resp, query,from,status)

		case "4":
		query = fmt.Sprintf(`SELECT rs.guid, rs.status,mr.fullname, mr.email, mr.icno, c.title, c.code
		FROM request_status as rs
		INNER JOIN membership_request mr ON mr.id = rs.membership_request_id AND mr.active = 1 AND mr.category = ?
		%s
		INNER JOIN card c ON c.id = mr.card_id AND c.active = 1
		WHERE rs.active = 1
		%s`,searchCondition,filterCondition)

			
		err = m.conn.QueryRowsCtx(ctx, &resp, query,from)
	}

    switch err {
    case nil:
        return &resp, nil
    case sqlx.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}