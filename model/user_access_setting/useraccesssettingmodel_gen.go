// Code generated by goctl. DO NOT EDIT.

package user_access_setting

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	userAccessSettingFieldNames          = builder.RawFieldNames(&UserAccessSetting{})
	userAccessSettingRows                = strings.Join(userAccessSettingFieldNames, ",")
	userAccessSettingRowsExpectAutoSet   = strings.Join(stringx.Remove(userAccessSettingFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	userAccessSettingRowsWithPlaceHolder = strings.Join(stringx.Remove(userAccessSettingFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
)

type (
	userAccessSettingModel interface {
		Insert(ctx context.Context, data *UserAccessSetting) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*UserAccessSetting, error)
		Update(ctx context.Context, data *UserAccessSetting) error
		Delete(ctx context.Context, id int64) error
		FindAll(ctx context.Context, id int64,referTable string) (*[]UserAccessSetting, error)
		FindAllPermission(ctx context.Context, id int64,referTable, title string) (*[]UserAccessSettings, error)
	}

	defaultUserAccessSettingModel struct {
		conn  sqlx.SqlConn
		table string
	}

	UserAccessSetting struct {
		Id                  int64         `db:"id"`
		StaffId             int64         `db:"staff_id"`
		MainModuleId        int64         `db:"main_module_id"`
		SubModuleReferTable string        `db:"sub_module_refer_table"` // Can be refer table or title
		SubModuleId         sql.NullInt64 `db:"sub_module_id"`
		AllowAdd            int64         `db:"allow_add"`    // 0-Not allow edit, 1- Active
		AllowEdit           int64         `db:"allow_edit"`   // 0-Not allow edit, 1- Active
		AllowDelete         int64         `db:"allow_delete"` // 0-Not allow edit, 1- Active
		AllowView           int64         `db:"allow_view"`   // 0-Not allow edit, 1- Active
		Updated             time.Time     `db:"updated"`
		Created             time.Time     `db:"created"`
		Active              int64         `db:"active"` // 0-Active, 1- Active
	}

	UserAccessSettings struct {
		Id                  int64         `db:"id"`
		StaffId             int64         `db:"staff_id"`
		MainModuleId        int64         `db:"main_module_id"`
		SubModuleReferTable string        `db:"sub_module_refer_table"` // Can be refer table or title
		SubModuleId         sql.NullInt64 `db:"sub_module_id"`
		AllowAdd            int64         `db:"allow_add"`    // 0-Not allow edit, 1- Active
		AllowEdit           int64         `db:"allow_edit"`   // 0-Not allow edit, 1- Active
		AllowDelete         int64         `db:"allow_delete"` // 0-Not allow edit, 1- Active
		AllowView           int64         `db:"allow_view"`   // 0-Not allow edit, 1- Active
		Updated             time.Time     `db:"updated"`
		Created             time.Time     `db:"created"`
		Active              int64         `db:"active"` // 0-Active, 1- Active
		Title 				string 		  `db:"title"`
	}

	Allow struct{
		Edit int64 `json:"edit"`
		Delete int64 `json:"delete"`
		Add int64 `json:"add"`
		View int64 `json:"view"`
	}

	Permission struct {
		Title string `json:"title"`
		Allow Allow `json:"allow"`
	}
)

func newUserAccessSettingModel(conn sqlx.SqlConn) *defaultUserAccessSettingModel {
	return &defaultUserAccessSettingModel{
		conn:  conn,
		table: "`user_access_setting`",
	}
}

func (m *defaultUserAccessSettingModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultUserAccessSettingModel) FindOne(ctx context.Context, id int64) (*UserAccessSetting, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", userAccessSettingRows, m.table)
	var resp UserAccessSetting
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUserAccessSettingModel) Insert(ctx context.Context, data *UserAccessSetting) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, userAccessSettingRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.StaffId, data.MainModuleId, data.SubModuleReferTable, data.SubModuleId, data.AllowAdd, data.AllowEdit, data.AllowDelete, data.AllowView, data.Updated, data.Created, data.Active)
	return ret, err
}

func (m *defaultUserAccessSettingModel) Update(ctx context.Context, data *UserAccessSetting) error {
	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, userAccessSettingRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, data.StaffId, data.MainModuleId, data.SubModuleReferTable, data.SubModuleId, data.AllowAdd, data.AllowEdit, data.AllowDelete, data.AllowView, data.Updated, data.Created, data.Active, data.Id)
	return err
}

func (m *defaultUserAccessSettingModel) tableName() string {
	return m.table
}

func (m *defaultUserAccessSettingModel) FindAll(ctx context.Context, id int64,referTable string) (*[]UserAccessSetting, error) {
	query := fmt.Sprintf("select %s from %s where `staff_id` = ? and `sub_module_refer_table` = ? and main_module_id = 1 ", userAccessSettingRows, m.table)
	var resp []UserAccessSetting
	err := m.conn.QueryRowsCtx(ctx, &resp, query, id,referTable)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultUserAccessSettingModel) FindAllPermission(ctx context.Context, id int64,referTable, title string) (*[]UserAccessSettings, error) {
	query := `
		SELECT s.*, sm.title
		FROM user_access_setting s
		LEFT JOIN sub_module sm ON s.sub_module_id = sm.id
		WHERE sm.active = 1
			AND sm.refer_title LIKE ?
			AND s.staff_id = ?
			AND s.sub_module_refer_table = ?
			AND s.active = 1
	`
	referTitle := "%" + title + "%"
	var resp []UserAccessSettings
	err := m.conn.QueryRowsCtx(ctx, &resp, query, referTitle, id, referTable)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
